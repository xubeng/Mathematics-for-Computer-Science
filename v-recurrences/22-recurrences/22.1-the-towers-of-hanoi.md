# 22.1 汉诺塔

有多种解决递归方程的方法。最简单的的方法就是去_猜_解决方案，然后使用归纳法_证明_该猜想是正确的。

    例如，作为在章节[16.4.2](https://finit-xu.gitbook.io/msc20180606/iii-counting/16-generating-functions/16.4-solving-linear-recurrences/16.4.2-the-towers-of-hanoi)中解决带有n个盘的汉诺塔问题需要移动的次数 $$T_n$$ 的生成的求导函数的替代选择，我们可以尝试猜。作为一个良好猜想的基础，让我们在1, 3, 7, 15, 31, 63上寻找一个计算 $$T_n$$ 值的模式。一个自然的猜想是$$T _n = 2^n -1$$。但是无论何时你猜想一个递归的解决方案，你都应该使用证明去验证它，典型的是使用归纳法。毕竟，你的猜想可能是错的（但是为何烦心去证明这种情况？毕竟，如果我们错了，它不是......的结尾，不，让我们检查下吧）。

**声明 22.1.1.** $$T _n = 2^n -1$$ _满足递归：_

        $$T_1 = 1  \\      T_n = 2T_{n-1} + 1  \space \space \space \space \space \space \space \space \space \space   (n\ge2).$$ 

_证明。_通过 $$n$$ 的归纳法证明。归纳假设是$$T _n = 2^n -1$$。因为$$T _1 = 1 = 2^1 -1$$，所以$$n = 1$$ 时成立。为了证明 $$n\ge2$$时，$$T _n = 2^n -1$$，现在假设$$T _{n-1} = 2^{n-1} -1$$：

        $$  T_n = 2T_{n-1} + 1 \\  = 2(2^{n-1} -1) + 1 \\ = 2^n  - 1$$ 

 第一个方程是递归方程，第二个方程遵循递归假设，最后一步是简化后的。    $$\blacksquare$$ 

    因为递归方程和归纳证明有相似的结构，这样的验证证明尤其干净。特别地，基本情况依赖于递归中定义 $$T_1$$ 的第一行。归纳步骤使用递归中的第二行，它将$$T_n $$定义为先前公式的函数。

    

